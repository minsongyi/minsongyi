'''
내림차순 배열을 받았다.

등수는 보통 위에서부터 몇 번째 있는 점수인지로 결정한다
하지만, 같은 점수가 있을 때는 그러한 점수의 등수 중에 가장 작은 등수가 된다.


100 90 90 80 80

앞에 애들중에서 자기랑 같은 점수는 빼고 더한게 등수이다.




100 : 1등
90: 2등
80: 4등

랭킹 리스트

랭킹 리스트에 올라 갈 수 있는 점수의 개수 P가 주어진다 ???????

랭킹 리스트 크기 P면 어떤 점수가지 올라갈 수 있을까 ????????????????????????????

입력은

N, 새로운점수, P

N : 리스트 길이

새로운 점수
P : ????


새로운 점수가 랭킹 리스트에서 몇 등 하는지 구하라.

점수가 랭킹 리스트에 올라갈 수 없을 정도로 낮다면 -1을 출력한다


3 90 2 // 10 : 랭킹 리스트에 올라갈 수 있는 점수의 개수
100 90 80


100 90 80 

만약, 랭킹 리스트가 꽉 차있을 때, 새 점수가 이전 점수보다 더 좋을 때만 점수가 바뀐다.

10 3 9
10 9 9 9 9 9 9 3 2 2 // 3

10 9 9 9 9 9 9 3 3 // 3

앞에 같은애들 있을 떄 조심한다

랭킹리스트가 넘쳐서 -1을 출력해야하진 않는지 조심한다


0 <= N <= 50
0<= P <= 50
0<=새로운 점수<= 너무큼


같은 숫자들이 있으면 앞에서? 뒤에서??

뒤에 넣어봤다

리스트의 꼴등보다 크면 넣을 수 있다 = 제대로된 등수를 가진다!!!!!

꼴등보다 작거나 같을때 자리가 남으면 넣을 수 있다.

아니면 -1


제대로된 등수를 가진다면, 몇등일까??????

빌보드에 자기보다 큰 점수 애들 + 1 이 내 등수이다.


'''
n, ns,p= [*map(int, input().split(' '))]
if n==0:
    print(1)
    exit()
L=[*map(int, input().split(' '))]
an=0
if n!=p:
    L.append(ns)  


elif n==p:
    if min(L)<ns:
        L.pop()
        L.append(ns) 
        #print(L)
    else:2509852497333272
        print(-1)
        exit()
L.sort()
#print(L)
#for i in range(0,len(L)):# n까지 돌리고 싶으면 n+1깢 for문을 돌려야한
#        mycard= L[i]
#        #print(i, len(L)-2-i, L[i], L[len(L)-2-i])
#        L[i]= L[len(L)-2-i]
#        L[len(L)-2-i]=mycard
#        #print(i, len(L)-2-i, L[i], L[len(L)-2-i])
#print(L)
for i in range(len(L)-1,-1 ,-1):
    if L[i]!=ns:
        an+=1
    elif L[i]==ns:
        an+=1
        print(an)
        break
